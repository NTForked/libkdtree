\hypertarget{pqueue_8c}{
\subsection{lib/pqueue.c File Reference}
\label{pqueue_8c}\index{lib/pqueue.c@{lib/pqueue.c}}
}
Two-ended priority queues (min-max heap). 

\subsubsection*{Functions}
\begin{CompactItemize}
\item 
struct \hyperlink{structpqueue}{pqueue} $\ast$ \hyperlink{pqueue_8c_e0b08acf0e2f96c3a8b4e3aa5b2805fc}{pqinit} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, uint32\_\-t n)
\begin{CompactList}\small\item\em Initialize priority queue. \item\end{CompactList}\item 
int \hyperlink{pqueue_8c_62a96e9a96adb156e3b4b445f7c0b633}{pqinsert} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$d)
\begin{CompactList}\small\item\em Insert an item into the queue. \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem} $\ast$$\ast$ \hyperlink{pqueue_8c_697e85ae9e6580b93e761e8e6652931e}{pqremove\_\-min} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$$\ast$d)
\begin{CompactList}\small\item\em remove the highest-ranking (minimum) item from the queue. \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem} $\ast$$\ast$ \hyperlink{pqueue_8c_970704b3665ed142ee44bed4cd2fcf59}{pqremove\_\-max} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$$\ast$d)
\begin{CompactList}\small\item\em remove the lowest-ranking (maximum) item from the queue. \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem} $\ast$$\ast$ \hyperlink{pqueue_8c_3dab0a996877fca6719d39b518143b0e}{pqpeek\_\-min} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$$\ast$d)
\begin{CompactList}\small\item\em access highest-ranking (minimum) item without removing it. \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem} $\ast$$\ast$ \hyperlink{pqueue_8c_670d5cddbb9137f12e13d1c0f9b69963}{pqpeek\_\-max} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$$\ast$d)
\begin{CompactList}\small\item\em access lowest-ranking (maximum) item without removing it. \item\end{CompactList}\end{CompactItemize}


\subsubsection{Detailed Description}
Two-ended priority queues (min-max heap). 

Implementation of a min-max heap (two-ended priority queue) as introduced by Atkinson et al. (1986), Communications of the ACM 10, 996. 

\subsubsection{Function Documentation}
\hypertarget{pqueue_8c_e0b08acf0e2f96c3a8b4e3aa5b2805fc}{
\index{pqueue.c@{pqueue.c}!pqinit@{pqinit}}
\index{pqinit@{pqinit}!pqueue.c@{pqueue.c}}
\paragraph[pqinit]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pqueue}$\ast$ pqinit (struct {\bf pqueue} $\ast$ {\em q}, \/  uint32\_\-t {\em n})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{pqueue_8c_e0b08acf0e2f96c3a8b4e3aa5b2805fc}


Initialize priority queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue, or NULL if the queue should be initialized.\item[{\em n}]the number of queue items for which memory should be preallocated. If you insert more than n items to the queue, another n items will be allocated automatically.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to priority queue, NULL in case of error. \end{Desc}
\hypertarget{pqueue_8c_62a96e9a96adb156e3b4b445f7c0b633}{
\index{pqueue.c@{pqueue.c}!pqinsert@{pqinsert}}
\index{pqinsert@{pqinsert}!pqueue.c@{pqueue.c}}
\paragraph[pqinsert]{\setlength{\rightskip}{0pt plus 5cm}int pqinsert (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$ {\em d})}\hfill}
\label{pqueue_8c_62a96e9a96adb156e3b4b445f7c0b633}


Insert an item into the queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]the datum to be inserted.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]1 if the item has been inserted, 0 if the item could not be appended. Either the queue pointer provided was NULL, or the function was unable to allocate the amount of memory needed for the new item. \end{Desc}
\hypertarget{pqueue_8c_670d5cddbb9137f12e13d1c0f9b69963}{
\index{pqueue.c@{pqueue.c}!pqpeek\_\-max@{pqpeek\_\-max}}
\index{pqpeek\_\-max@{pqpeek\_\-max}!pqueue.c@{pqueue.c}}
\paragraph[pqpeek\_\-max]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf resItem}$\ast$$\ast$ pqpeek\_\-max (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$$\ast$ {\em d})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{pqueue_8c_670d5cddbb9137f12e13d1c0f9b69963}


access lowest-ranking (maximum) item without removing it. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]a pointer to the struct \hyperlink{structresItem}{resItem} $\ast$ variable that will hold the datum corresponding to the highest-ranking item.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]non-NULL in case of success. The variable that d points to now contains the datum associated with the highest-ranking item; NULL in case of failure. Either the queue pointer provided was NULL, or the queue was empty. The chunk of memory that d points to has not been modified. \end{Desc}
\hypertarget{pqueue_8c_3dab0a996877fca6719d39b518143b0e}{
\index{pqueue.c@{pqueue.c}!pqpeek\_\-min@{pqpeek\_\-min}}
\index{pqpeek\_\-min@{pqpeek\_\-min}!pqueue.c@{pqueue.c}}
\paragraph[pqpeek\_\-min]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf resItem}$\ast$$\ast$ pqpeek\_\-min (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$$\ast$ {\em d})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{pqueue_8c_3dab0a996877fca6719d39b518143b0e}


access highest-ranking (minimum) item without removing it. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]a pointer to the struct \hyperlink{structresItem}{resItem} $\ast$ variable that will hold the datum corresponding to the highest-ranking item.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]non-NULL in case of success. The variable that d points to now contains the datum associated with the highest-ranking item; NULL in case of failure. Either the queue pointer provided was NULL, or the queue was empty. The chunk of memory that d points to has not been modified. \end{Desc}
\hypertarget{pqueue_8c_970704b3665ed142ee44bed4cd2fcf59}{
\index{pqueue.c@{pqueue.c}!pqremove\_\-max@{pqremove\_\-max}}
\index{pqremove\_\-max@{pqremove\_\-max}!pqueue.c@{pqueue.c}}
\paragraph[pqremove\_\-max]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf resItem}$\ast$$\ast$ pqremove\_\-max (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$$\ast$ {\em d})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{pqueue_8c_970704b3665ed142ee44bed4cd2fcf59}


remove the lowest-ranking (maximum) item from the queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]a pointer to the struct \hyperlink{structresItem}{resItem} $\ast$ variable that will hold the datum corresponding to the queue item removed.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]non-NULL if an item has been removed. The variable that d points to now contains the datum associated with the item in question; or NULL if item could be removed. Either the queue pointer provided was NULL, or the queue was empty. The chunk of memory that d points to has not been modified. \end{Desc}
\hypertarget{pqueue_8c_697e85ae9e6580b93e761e8e6652931e}{
\index{pqueue.c@{pqueue.c}!pqremove\_\-min@{pqremove\_\-min}}
\index{pqremove\_\-min@{pqremove\_\-min}!pqueue.c@{pqueue.c}}
\paragraph[pqremove\_\-min]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf resItem}$\ast$$\ast$ pqremove\_\-min (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$$\ast$ {\em d})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{pqueue_8c_697e85ae9e6580b93e761e8e6652931e}


remove the highest-ranking (minimum) item from the queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]a pointer to the struct \hyperlink{structresItem}{resItem} $\ast$ variable that will hold the datum corresponding to the queue item removed.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]non-NULL if an item has been removed. The variable that d points to now contains the datum associated with the item in question; or NULL if item could be removed. Either the queue pointer provided was NULL, or the queue was empty. The chunk of memory that d points to has not been modified. \end{Desc}
