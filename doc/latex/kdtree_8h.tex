\hypertarget{kdtree_8h}{
\subsection{lib/kdtree.h File Reference}
\label{kdtree_8h}\index{lib/kdtree.h@{lib/kdtree.h}}
}
Include file for the kdtree library. 

\subsubsection*{Data Structures}
\begin{CompactItemize}
\item 
struct \hyperlink{structkdNode}{kdNode}
\begin{CompactList}\small\item\em kd-tree node structure definition \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem}
\begin{CompactList}\small\item\em result items, member of a priority queue \item\end{CompactList}\item 
struct \hyperlink{structpqueue}{pqueue}
\begin{CompactList}\small\item\em priority queue (min-max heap) \item\end{CompactList}\item 
struct \hyperlink{structkd__thread__data}{kd\_\-thread\_\-data}
\begin{CompactList}\small\item\em arguments passed to the threaded kd-Tree construction \item\end{CompactList}\end{CompactItemize}
\subsubsection*{Functions}
\begin{CompactItemize}
\item 
struct \hyperlink{structpqueue}{pqueue} $\ast$ \hyperlink{kdtree_8h_e0b08acf0e2f96c3a8b4e3aa5b2805fc}{pqinit} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, uint32\_\-t n)
\begin{CompactList}\small\item\em Initialize priority queue. \item\end{CompactList}\item 
int \hyperlink{kdtree_8h_62a96e9a96adb156e3b4b445f7c0b633}{pqinsert} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$d)
\begin{CompactList}\small\item\em Insert an item into the queue. \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem} $\ast$$\ast$ \hyperlink{kdtree_8h_697e85ae9e6580b93e761e8e6652931e}{pqremove\_\-min} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$$\ast$d)
\begin{CompactList}\small\item\em remove the highest-ranking (minimum) item from the queue. \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem} $\ast$$\ast$ \hyperlink{kdtree_8h_970704b3665ed142ee44bed4cd2fcf59}{pqremove\_\-max} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$$\ast$d)
\begin{CompactList}\small\item\em remove the lowest-ranking (maximum) item from the queue. \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem} $\ast$$\ast$ \hyperlink{kdtree_8h_3dab0a996877fca6719d39b518143b0e}{pqpeek\_\-min} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$$\ast$d)
\begin{CompactList}\small\item\em access highest-ranking (minimum) item without removing it. \item\end{CompactList}\item 
struct \hyperlink{structresItem}{resItem} $\ast$$\ast$ \hyperlink{kdtree_8h_670d5cddbb9137f12e13d1c0f9b69963}{pqpeek\_\-max} (struct \hyperlink{structpqueue}{pqueue} $\ast$q, struct \hyperlink{structresItem}{resItem} $\ast$$\ast$d)
\begin{CompactList}\small\item\em access lowest-ranking (maximum) item without removing it. \item\end{CompactList}\item 
float \hyperlink{kdtree_8h_7d710e611189fff7d0bab69a805a1be6}{kd\_\-sph\_\-xtd} (float $\ast$p1, float $\ast$p2, float $\ast$p3)
\begin{CompactList}\small\item\em Compute cross-track distance. \item\end{CompactList}\item 
void \hyperlink{kdtree_8h_13ef2f8b845d1b904f47a8954164521f}{kd\_\-destroyTree} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, void($\ast$destr)(void $\ast$))
\begin{CompactList}\small\item\em free the kd-tree data structure, \item\end{CompactList}\item 
struct \hyperlink{structkdNode}{kdNode} $\ast$ \hyperlink{kdtree_8h_87b949986bab7fbea42e703eb070f8eb}{kd\_\-buildTree} (struct kd\_\-point $\ast$points, unsigned long nPoints, void $\ast$($\ast$constr)(void $\ast$), void($\ast$destr)(void $\ast$), float $\ast$min, float $\ast$max, int dim, int max\_\-threads)
\begin{CompactList}\small\item\em build kd-tree structure \item\end{CompactList}\item 
struct \hyperlink{structkdNode}{kdNode} $\ast$ \hyperlink{kdtree_8h_b405951046c5fb4b748fa204cb4754ca}{kd\_\-sph\_\-buildTree} (struct kd\_\-point $\ast$points, unsigned long nPoints, void $\ast$($\ast$constr)(void $\ast$), void($\ast$destr)(void $\ast$), float $\ast$min, float $\ast$max, int max\_\-threads)
\begin{CompactList}\small\item\em build kd-tree structure \item\end{CompactList}\item 
struct \hyperlink{structpqueue}{pqueue} $\ast$ \hyperlink{kdtree_8h_617ec34cd57f74373f2b076f68bb0725}{kd\_\-ortRangeSearch} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, float $\ast$min, float $\ast$max, int dim)
\begin{CompactList}\small\item\em Perform orthogonal range search (get all points in a hyperrectangle). \item\end{CompactList}\item 
struct \hyperlink{structkdNode}{kdNode} $\ast$ \hyperlink{kdtree_8h_c1a9dd9e9287a3527a69aed20c1661d3}{kd\_\-nearest} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, float $\ast$p, float $\ast$max\_\-dist\_\-sq, int dim)
\begin{CompactList}\small\item\em Find the nearest neighbor of a point. \item\end{CompactList}\item 
struct \hyperlink{structpqueue}{pqueue} $\ast$ \hyperlink{kdtree_8h_b974c9c2fb71896b9b044f340f6afc56}{kd\_\-qnearest} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, float $\ast$p, float $\ast$max\_\-dist\_\-sq, unsigned int q, int dim)
\begin{CompactList}\small\item\em Return the q nearest-neighbors to a point. \item\end{CompactList}\item 
struct \hyperlink{structpqueue}{pqueue} $\ast$ \hyperlink{kdtree_8h_23e1d72de397f86f0b13b2cc4d6c72d0}{kd\_\-range} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, float $\ast$p, float $\ast$max\_\-dist\_\-sq, int dim, int ordered)
\begin{CompactList}\small\item\em Perform a range search around a point. \item\end{CompactList}\item 
struct \hyperlink{structpqueue}{pqueue} $\ast$ \hyperlink{kdtree_8h_0c97608c283a99ff3aa18d55ceabc064}{kd\_\-sph\_\-ortRangeSearch} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, float $\ast$min, float $\ast$max)
\begin{CompactList}\small\item\em Perform orthogonal range search (get all points in a hyperrectangle). \item\end{CompactList}\item 
struct \hyperlink{structkdNode}{kdNode} $\ast$ \hyperlink{kdtree_8h_ffbfb5c1126325870161bde34d7343b5}{kd\_\-sph\_\-nearest} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, float $\ast$p, float $\ast$max\_\-dist\_\-sq)
\begin{CompactList}\small\item\em Find the nearest neighbor of a point. \item\end{CompactList}\item 
struct \hyperlink{structpqueue}{pqueue} $\ast$ \hyperlink{kdtree_8h_3149e46c69685e4542785a457688c041}{kd\_\-sph\_\-qnearest} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, float $\ast$p, float $\ast$max\_\-dist\_\-sq, unsigned int q)
\begin{CompactList}\small\item\em Return the q nearest-neighbors to a point. \item\end{CompactList}\item 
struct \hyperlink{structpqueue}{pqueue} $\ast$ \hyperlink{kdtree_8h_d364613d93fd76bb98202c11c0fdae1d}{kd\_\-sph\_\-range} (struct \hyperlink{structkdNode}{kdNode} $\ast$node, float $\ast$p, float $\ast$max\_\-dist\_\-sq, int ordered)
\begin{CompactList}\small\item\em Perform a range search around a point. \item\end{CompactList}\end{CompactItemize}


\subsubsection{Detailed Description}
Include file for the kdtree library. 



\subsubsection{Function Documentation}
\hypertarget{kdtree_8h_87b949986bab7fbea42e703eb070f8eb}{
\index{kdtree.h@{kdtree.h}!kd\_\-buildTree@{kd\_\-buildTree}}
\index{kd\_\-buildTree@{kd\_\-buildTree}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-buildTree]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf kdNode}$\ast$ kd\_\-buildTree (struct kd\_\-point $\ast$ {\em points}, \/  unsigned long {\em nPoints}, \/  void $\ast$($\ast$)(void $\ast$) {\em constr}, \/  void($\ast$)(void $\ast$) {\em destr}, \/  float $\ast$ {\em min}, \/  float $\ast$ {\em max}, \/  int {\em dim}, \/  int {\em max\_\-threads})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_87b949986bab7fbea42e703eb070f8eb}


build kd-tree structure 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em points}]an array of kd\_\-points (struct with position vector and data container).\item[{\em nPoints}]the length of the points array.\item[{\em constr}]a pointer to a void $\ast$constructor() function to include the data container in the tree; optional, can be NULL\item[{\em destr}]a pointer to a void destructor() function to free() the data containers in the tree; optional, can be NULL, but should be given if the constr argument is non-NULL.\item[{\em min}]a vector with the minimum positions of the corners of the hyperrectangle containing the data.\item[{\em max}]a vector with the maximum positions of the corners of the hyperrectangle containing the data.\item[{\em dim}]the dimensionality of the data.\item[{\em max\_\-threads}]the maximal number of threads spawned for construction of the tree. The threads will be unbalanced if this is not a power of 2.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]root node of the tree \end{Desc}
\hypertarget{kdtree_8h_13ef2f8b845d1b904f47a8954164521f}{
\index{kdtree.h@{kdtree.h}!kd\_\-destroyTree@{kd\_\-destroyTree}}
\index{kd\_\-destroyTree@{kd\_\-destroyTree}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-destroyTree]{\setlength{\rightskip}{0pt plus 5cm}void kd\_\-destroyTree (struct {\bf kdNode} $\ast$ {\em node}, \/  void($\ast$)(void $\ast$) {\em destr})}\hfill}
\label{kdtree_8h_13ef2f8b845d1b904f47a8954164521f}


free the kd-tree data structure, 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of the tree to be destroyed\item[{\em $\ast$destr}]a pointer to the destructor function for the data container.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]This function does not return a value \end{Desc}
\hypertarget{kdtree_8h_c1a9dd9e9287a3527a69aed20c1661d3}{
\index{kdtree.h@{kdtree.h}!kd\_\-nearest@{kd\_\-nearest}}
\index{kd\_\-nearest@{kd\_\-nearest}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-nearest]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf kdNode}$\ast$ kd\_\-nearest (struct {\bf kdNode} $\ast$ {\em node}, \/  float $\ast$ {\em p}, \/  float $\ast$ {\em max\_\-dist\_\-sq}, \/  int {\em dim})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_c1a9dd9e9287a3527a69aed20c1661d3}


Find the nearest neighbor of a point. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of the tree to be searched.\item[{\em p}]a vector to the point whose nearest neighbor is sought.\item[{\em max\_\-dist\_\-sq}]the square of the maximum distance to the nearest neighbor.\item[{\em dim}]the dimension of the data.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A pointer to node containing the nearest neighbor. max\_\-dist\_\-sq is set to the square of the distance to the nearest neigbor. \end{Desc}
\hypertarget{kdtree_8h_617ec34cd57f74373f2b076f68bb0725}{
\index{kdtree.h@{kdtree.h}!kd\_\-ortRangeSearch@{kd\_\-ortRangeSearch}}
\index{kd\_\-ortRangeSearch@{kd\_\-ortRangeSearch}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-ortRangeSearch]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pqueue}$\ast$ kd\_\-ortRangeSearch (struct {\bf kdNode} $\ast$ {\em node}, \/  float $\ast$ {\em min}, \/  float $\ast$ {\em max}, \/  int {\em dim})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_617ec34cd57f74373f2b076f68bb0725}


Perform orthogonal range search (get all points in a hyperrectangle). 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of tree to be searched.\item[{\em min}]a vector with the minimum positions of the corners of the hyperrectangle containing the data.\item[{\em max}]a vector with the maximum positions of the corners of the hyperrectangle containing the data.\item[{\em dim}]the dimension of the data.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to a priority queue, NULL in case of problems. \end{Desc}
\hypertarget{kdtree_8h_b974c9c2fb71896b9b044f340f6afc56}{
\index{kdtree.h@{kdtree.h}!kd\_\-qnearest@{kd\_\-qnearest}}
\index{kd\_\-qnearest@{kd\_\-qnearest}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-qnearest]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pqueue}$\ast$ kd\_\-qnearest (struct {\bf kdNode} $\ast$ {\em node}, \/  float $\ast$ {\em p}, \/  float $\ast$ {\em max\_\-dist\_\-sq}, \/  unsigned int {\em q}, \/  int {\em dim})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_b974c9c2fb71896b9b044f340f6afc56}


Return the q nearest-neighbors to a point. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of the tree to be searched.\item[{\em p}]a vector to the point whose nearest neighbors are sought.\item[{\em max\_\-dist\_\-sq}]the square of the maximum distance to the nearest neighbors.\item[{\em q}]the maximum number of points to be retured.\item[{\em dim}]the dimension of the data.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A pointer to a priority queue of the points found, or NULL in case of problems. \end{Desc}
\hypertarget{kdtree_8h_23e1d72de397f86f0b13b2cc4d6c72d0}{
\index{kdtree.h@{kdtree.h}!kd\_\-range@{kd\_\-range}}
\index{kd\_\-range@{kd\_\-range}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-range]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pqueue}$\ast$ kd\_\-range (struct {\bf kdNode} $\ast$ {\em node}, \/  float $\ast$ {\em p}, \/  float $\ast$ {\em max\_\-dist\_\-sq}, \/  int {\em dim}, \/  int {\em ordered})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_23e1d72de397f86f0b13b2cc4d6c72d0}


Perform a range search around a point. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of the tree to be searched.\item[{\em p}]the location of the point around which the search is carried out .\item[{\em max\_\-dist\_\-sq}]the square of the radius of the hypersphere.\item[{\em dim}]the dimension of the data. \item[{\em ordered}]determines whether the result list should be ordered in increasing distance (KD\_\-ORDERED) or unordered (KD\_\-UNORDERED).\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A pointer to a priority queue containing the points found, NULL in case of problems. \end{Desc}
\hypertarget{kdtree_8h_b405951046c5fb4b748fa204cb4754ca}{
\index{kdtree.h@{kdtree.h}!kd\_\-sph\_\-buildTree@{kd\_\-sph\_\-buildTree}}
\index{kd\_\-sph\_\-buildTree@{kd\_\-sph\_\-buildTree}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-sph\_\-buildTree]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf kdNode}$\ast$ kd\_\-sph\_\-buildTree (struct kd\_\-point $\ast$ {\em points}, \/  unsigned long {\em nPoints}, \/  void $\ast$($\ast$)(void $\ast$) {\em constr}, \/  void($\ast$)(void $\ast$) {\em destr}, \/  float $\ast$ {\em min}, \/  float $\ast$ {\em max}, \/  int {\em max\_\-threads})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_b405951046c5fb4b748fa204cb4754ca}


build kd-tree structure 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em points}]an array of kd\_\-points (struct with position vector and data container).\item[{\em nPoints}]the length of the points array.\item[{\em constr}]a pointer to a void $\ast$constructor() function to include data container in tree; optional, can be NULL\item[{\em destr}]a pointer to a void destructor() function to free() data container in the tree; optional, can be NULL, but should be given if the constr argument is non-NULL.\item[{\em min}]a vector with the minimum positions of the corners of the hyperrectangle containing the data.\item[{\em max}]a vector with the maximum positions of the corners of the hyperrectangle containing the data.\item[{\em max\_\-threads}]the maximal number of threads spawned for construction of the tree. The threads will be unbalanced if this is not a power of 2.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]root node of the tree \end{Desc}
\hypertarget{kdtree_8h_ffbfb5c1126325870161bde34d7343b5}{
\index{kdtree.h@{kdtree.h}!kd\_\-sph\_\-nearest@{kd\_\-sph\_\-nearest}}
\index{kd\_\-sph\_\-nearest@{kd\_\-sph\_\-nearest}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-sph\_\-nearest]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf kdNode}$\ast$ kd\_\-sph\_\-nearest (struct {\bf kdNode} $\ast$ {\em node}, \/  float $\ast$ {\em p}, \/  float $\ast$ {\em max\_\-dist\_\-sq})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_ffbfb5c1126325870161bde34d7343b5}


Find the nearest neighbor of a point. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of the tree to be searched.\item[{\em p}]a vector to the point whose nearest neighbor is sought.\item[{\em max\_\-dist\_\-sq}]the square of the maximum distance to the nearest neighbor.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A pointer to node containing the nearest neighbor. max\_\-dist\_\-sq is set to the square of the distance to the nearest neigbor. \end{Desc}
\hypertarget{kdtree_8h_0c97608c283a99ff3aa18d55ceabc064}{
\index{kdtree.h@{kdtree.h}!kd\_\-sph\_\-ortRangeSearch@{kd\_\-sph\_\-ortRangeSearch}}
\index{kd\_\-sph\_\-ortRangeSearch@{kd\_\-sph\_\-ortRangeSearch}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-sph\_\-ortRangeSearch]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pqueue}$\ast$ kd\_\-sph\_\-ortRangeSearch (struct {\bf kdNode} $\ast$ {\em node}, \/  float $\ast$ {\em min}, \/  float $\ast$ {\em max})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_0c97608c283a99ff3aa18d55ceabc064}


Perform orthogonal range search (get all points in a hyperrectangle). 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of tree to be searched.\item[{\em min}]a vector with the minimum positions of the corners of the hyperrectangle containing the data.\item[{\em max}]a vector with the maximum positions of the corners of the hyperrectangle containing the data.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to a priority queue, NULL in case of problems.\end{Desc}
Rectangle must not cross the meridian! \hypertarget{kdtree_8h_3149e46c69685e4542785a457688c041}{
\index{kdtree.h@{kdtree.h}!kd\_\-sph\_\-qnearest@{kd\_\-sph\_\-qnearest}}
\index{kd\_\-sph\_\-qnearest@{kd\_\-sph\_\-qnearest}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-sph\_\-qnearest]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pqueue}$\ast$ kd\_\-sph\_\-qnearest (struct {\bf kdNode} $\ast$ {\em node}, \/  float $\ast$ {\em p}, \/  float $\ast$ {\em max\_\-dist\_\-sq}, \/  unsigned int {\em q})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_3149e46c69685e4542785a457688c041}


Return the q nearest-neighbors to a point. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of the tree to be searched.\item[{\em p}]a vector to the point whose nearest neighbors are sought.\item[{\em max\_\-dist\_\-sq}]the square of the maximum distance to the nearest neighbors.\item[{\em q}]the maximum number of points to be retured.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A pointer to a priority queue of the points found, or NULL in case of problems. \end{Desc}
\hypertarget{kdtree_8h_d364613d93fd76bb98202c11c0fdae1d}{
\index{kdtree.h@{kdtree.h}!kd\_\-sph\_\-range@{kd\_\-sph\_\-range}}
\index{kd\_\-sph\_\-range@{kd\_\-sph\_\-range}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-sph\_\-range]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pqueue}$\ast$ kd\_\-sph\_\-range (struct {\bf kdNode} $\ast$ {\em node}, \/  float $\ast$ {\em p}, \/  float $\ast$ {\em max\_\-dist\_\-sq}, \/  int {\em ordered})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_d364613d93fd76bb98202c11c0fdae1d}


Perform a range search around a point. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em node}]the root node of the tree to be searched.\item[{\em p}]the location of the point around which the search is carried out .\item[{\em max\_\-dist\_\-sq}]the square of the radius of the hypersphere.\item[{\em ordered}]determines whether the result list should be ordered in increasing distance (KD\_\-ORDERED) or unordered (KD\_\-UNORDERED).\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A pointer to a priority queue containing the points found, NULL in case of problems. \end{Desc}
\hypertarget{kdtree_8h_7d710e611189fff7d0bab69a805a1be6}{
\index{kdtree.h@{kdtree.h}!kd\_\-sph\_\-xtd@{kd\_\-sph\_\-xtd}}
\index{kd\_\-sph\_\-xtd@{kd\_\-sph\_\-xtd}!kdtree.h@{kdtree.h}}
\paragraph[kd\_\-sph\_\-xtd]{\setlength{\rightskip}{0pt plus 5cm}float kd\_\-sph\_\-xtd (float $\ast$ {\em p1}, \/  float $\ast$ {\em p2}, \/  float $\ast$ {\em p3})}\hfill}
\label{kdtree_8h_7d710e611189fff7d0bab69a805a1be6}


Compute cross-track distance. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p1}]a point\item[{\em p2}]a second point defining a great circle from p1\item[{\em p3}]a third point whose distance from the great circle we compute\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]distance of p3 from the great circle connecting p1 and p2. \end{Desc}
\hypertarget{kdtree_8h_e0b08acf0e2f96c3a8b4e3aa5b2805fc}{
\index{kdtree.h@{kdtree.h}!pqinit@{pqinit}}
\index{pqinit@{pqinit}!kdtree.h@{kdtree.h}}
\paragraph[pqinit]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pqueue}$\ast$ pqinit (struct {\bf pqueue} $\ast$ {\em q}, \/  uint32\_\-t {\em n})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_e0b08acf0e2f96c3a8b4e3aa5b2805fc}


Initialize priority queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue, or NULL if the queue should be initialized.\item[{\em n}]the number of queue items for which memory should be preallocated. If you insert more than n items to the queue, another n items will be allocated automatically.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to priority queue, NULL in case of error. \end{Desc}
\hypertarget{kdtree_8h_62a96e9a96adb156e3b4b445f7c0b633}{
\index{kdtree.h@{kdtree.h}!pqinsert@{pqinsert}}
\index{pqinsert@{pqinsert}!kdtree.h@{kdtree.h}}
\paragraph[pqinsert]{\setlength{\rightskip}{0pt plus 5cm}int pqinsert (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$ {\em d})}\hfill}
\label{kdtree_8h_62a96e9a96adb156e3b4b445f7c0b633}


Insert an item into the queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]the datum to be inserted.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]1 if the item has been inserted, 0 if the item could not be appended. Either the queue pointer provided was NULL, or the function was unable to allocate the amount of memory needed for the new item. \end{Desc}
\hypertarget{kdtree_8h_670d5cddbb9137f12e13d1c0f9b69963}{
\index{kdtree.h@{kdtree.h}!pqpeek\_\-max@{pqpeek\_\-max}}
\index{pqpeek\_\-max@{pqpeek\_\-max}!kdtree.h@{kdtree.h}}
\paragraph[pqpeek\_\-max]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf resItem}$\ast$$\ast$ pqpeek\_\-max (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$$\ast$ {\em d})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_670d5cddbb9137f12e13d1c0f9b69963}


access lowest-ranking (maximum) item without removing it. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]a pointer to the struct \hyperlink{structresItem}{resItem} $\ast$ variable that will hold the datum corresponding to the highest-ranking item.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]non-NULL in case of success. The variable that d points to now contains the datum associated with the highest-ranking item; NULL in case of failure. Either the queue pointer provided was NULL, or the queue was empty. The chunk of memory that d points to has not been modified. \end{Desc}
\hypertarget{kdtree_8h_3dab0a996877fca6719d39b518143b0e}{
\index{kdtree.h@{kdtree.h}!pqpeek\_\-min@{pqpeek\_\-min}}
\index{pqpeek\_\-min@{pqpeek\_\-min}!kdtree.h@{kdtree.h}}
\paragraph[pqpeek\_\-min]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf resItem}$\ast$$\ast$ pqpeek\_\-min (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$$\ast$ {\em d})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_3dab0a996877fca6719d39b518143b0e}


access highest-ranking (minimum) item without removing it. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]a pointer to the struct \hyperlink{structresItem}{resItem} $\ast$ variable that will hold the datum corresponding to the highest-ranking item.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]non-NULL in case of success. The variable that d points to now contains the datum associated with the highest-ranking item; NULL in case of failure. Either the queue pointer provided was NULL, or the queue was empty. The chunk of memory that d points to has not been modified. \end{Desc}
\hypertarget{kdtree_8h_970704b3665ed142ee44bed4cd2fcf59}{
\index{kdtree.h@{kdtree.h}!pqremove\_\-max@{pqremove\_\-max}}
\index{pqremove\_\-max@{pqremove\_\-max}!kdtree.h@{kdtree.h}}
\paragraph[pqremove\_\-max]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf resItem}$\ast$$\ast$ pqremove\_\-max (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$$\ast$ {\em d})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_970704b3665ed142ee44bed4cd2fcf59}


remove the lowest-ranking (maximum) item from the queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]a pointer to the struct \hyperlink{structresItem}{resItem} $\ast$ variable that will hold the datum corresponding to the queue item removed.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]non-NULL if an item has been removed. The variable that d points to now contains the datum associated with the item in question; or NULL if item could be removed. Either the queue pointer provided was NULL, or the queue was empty. The chunk of memory that d points to has not been modified. \end{Desc}
\hypertarget{kdtree_8h_697e85ae9e6580b93e761e8e6652931e}{
\index{kdtree.h@{kdtree.h}!pqremove\_\-min@{pqremove\_\-min}}
\index{pqremove\_\-min@{pqremove\_\-min}!kdtree.h@{kdtree.h}}
\paragraph[pqremove\_\-min]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf resItem}$\ast$$\ast$ pqremove\_\-min (struct {\bf pqueue} $\ast$ {\em q}, \/  struct {\bf resItem} $\ast$$\ast$ {\em d})\hspace{0.3cm}{\tt  \mbox{[}read\mbox{]}}}\hfill}
\label{kdtree_8h_697e85ae9e6580b93e761e8e6652931e}


remove the highest-ranking (minimum) item from the queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]a pointer to a priority queue.\item[{\em d}]a pointer to the struct \hyperlink{structresItem}{resItem} $\ast$ variable that will hold the datum corresponding to the queue item removed.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]non-NULL if an item has been removed. The variable that d points to now contains the datum associated with the item in question; or NULL if item could be removed. Either the queue pointer provided was NULL, or the queue was empty. The chunk of memory that d points to has not been modified. \end{Desc}
